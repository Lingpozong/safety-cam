<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WalkSafe AI Ultimate</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #00f3ff;
            --danger-color: #ff2a2a;
            --bg-glass: rgba(20, 20, 20, 0.75);
            --border-glass: rgba(255, 255, 255, 0.15);
        }

        body { 
            margin: 0; background: black; overflow: hidden; 
            font-family: 'Rajdhani', sans-serif;
            touch-action: manipulation;
            color: white;
        }
        
        #video, #pip-video { position: absolute; width: 1px; height: 1px; opacity: 0; pointer-events: none; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }

        /* æ‰«æçº¿ */
        .scan-line {
            position: absolute; top: 0; left: 0; width: 100%; height: 5px;
            background: linear-gradient(to right, transparent, var(--primary-color), transparent);
            opacity: 0.5; z-index: 2; pointer-events: none;
            animation: scan 3s linear infinite; display: none;
        }
        @keyframes scan { 0% { top: 0%; } 100% { top: 100%; } }

        /* é¡¶éƒ¨çŠ¶æ€æ  */
        #top-bar {
            position: absolute; top: 0; left: 0; width: 100%; height: 60px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            z-index: 10; display: flex; align-items: center; justify-content: space-between;
            padding: 0 20px; box-sizing: border-box; pointer-events: none;
        }
        .status-badge {
            background: rgba(0, 243, 255, 0.1); border: 1px solid var(--primary-color);
            padding: 5px 12px; border-radius: 4px; font-size: 14px; color: var(--primary-color);
            text-shadow: 0 0 5px var(--primary-color); letter-spacing: 1px;
        }

        /* åº•éƒ¨æ§åˆ¶å° (è°ƒæ•´ä¸ºå®¹çº³3ä¸ªæŒ‰é’®) */
        #control-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 450px;
            background: var(--bg-glass);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--border-glass);
            border-radius: 20px; padding: 15px 10px;
            display: flex; justify-content: space-between; align-items: center;
            z-index: 20; display: none;
        }

        .ctrl-btn {
            background: transparent; border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 8px 0; width: 32%; /* å˜çª„ä»¥æ”¾ä¸‹3ä¸ªæŒ‰é’® */
            border-radius: 12px;
            font-family: 'Rajdhani', sans-serif; font-weight: 700; font-size: 14px;
            cursor: pointer; transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; gap: 4px;
        }
        .ctrl-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.1); }
        .ctrl-btn.active { 
            background: rgba(0, 243, 255, 0.2); 
            border-color: var(--primary-color); 
            color: var(--primary-color);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }

        /* å¯åŠ¨å±å¹• */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: black; z-index: 50;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .glow-circle {
            width: 120px; height: 120px; border-radius: 50%;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 20px var(--primary-color), inset 0 0 20px var(--primary-color);
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 20px var(--primary-color); transform: scale(1); }
            50% { box-shadow: 0 0 40px var(--primary-color); transform: scale(1.05); }
            100% { box-shadow: 0 0 20px var(--primary-color); transform: scale(1); }
        }
        .start-text { font-size: 18px; font-weight: bold; color: var(--primary-color); }
        .sub-text { margin-top: 20px; color: #888; font-size: 12px; text-transform: uppercase; letter-spacing: 2px;}

        /* è­¦å‘Šè¦†ç›–å±‚ */
        #danger-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(255, 0, 0, 0.8) 100%);
            z-index: 5; display: none; pointer-events: none;
            border: 4px solid red; box-sizing: border-box;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <div class="glow-circle" onclick="startSystem()">
            <span class="start-text">INITIALIZE</span>
        </div>
        <div class="sub-text">WalkSafe AI Protection</div>
    </div>

    <div id="top-bar" style="display:none;">
        <div class="status-badge">â— LIVE</div>
        <div class="status-badge" id="fps-badge">AI: READY</div>
    </div>
    <div class="scan-line" id="scan-line"></div>
    <div id="danger-overlay"></div>

    <video id="video" playsinline muted autoplay loop></video>
    <canvas id="canvas"></canvas>
    <video id="pip-video" playsinline muted autoplay loop></video>

    <div id="control-panel">
        <button id="mode-btn" class="ctrl-btn" onclick="toggleAlertMode()">
            <span>ğŸš¨ ALERT</span>
            <span id="mode-text" style="font-size:10px; opacity:0.7">SOUND+VIB</span>
        </button>
        <button id="eco-btn" class="ctrl-btn" onclick="toggleEcoMode()">
            <span>âš¡ï¸ ECO</span>
            <span style="font-size:10px; opacity:0.7">OFF</span>
        </button>
        <button id="pip-btn" class="ctrl-btn" onclick="togglePiP()">
            <span>ğŸ“º PiP</span>
            <span style="font-size:10px; opacity:0.7">OPEN</span>
        </button>
    </div>

<script>
    const video = document.getElementById('video');
    const pipVideo = document.getElementById('pip-video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const startScreen = document.getElementById('start-screen');
    const controlPanel = document.getElementById('control-panel');
    const topBar = document.getElementById('top-bar');
    const scanLine = document.getElementById('scan-line');
    const dangerOverlay = document.getElementById('danger-overlay');
    const fpsBadge = document.getElementById('fps-badge');
    const ecoBtn = document.getElementById('eco-btn');
    const modeBtn = document.getElementById('mode-btn');
    const modeText = document.getElementById('mode-text');

    let model = null;
    let isEcoMode = false;
    let audioCtx = null;
    let isDetecting = false; 
    let lastPredictionTime = 0;
    const PREDICTION_INTERVAL = 200; 
    const CONFIDENCE_THRESHOLD = 0.6; 
    
    let lastDangerTime = 0;        
    const DANGER_HOLD_TIME = 800;  
    
    let lastBeepTime = 0;
    const BEEP_INTERVAL = 500;     
    
    // --- æ–°å¢ï¼šè­¦æŠ¥æ¨¡å¼çŠ¶æ€ ---
    // 0: Sound Only, 1: Vibrate Only, 2: Both
    let alertMode = 2; 
    
    let pipTarget = video; 
    let frameCount = 0; 
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);

    async function startSystem() {
        startScreen.style.display = 'none';
        
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            if (AudioContext) {
                audioCtx = new AudioContext();
                if (audioCtx.state === 'suspended') await audioCtx.resume();
                startSilentHeartbeat();
            }

            if (window.Notification && Notification.permission !== "granted") {
                await Notification.requestPermission();
            }
            
            await setupCamera();
            
            topBar.style.display = 'flex';
            controlPanel.style.display = 'flex';
            scanLine.style.display = 'block';

            if (isIOS) {
                pipTarget = video; 
            } else {
                try {
                    const stream = canvas.captureStream(30);
                    if (stream.getVideoTracks().length > 0) {
                        pipVideo.srcObject = stream;
                        await new Promise(r => setTimeout(r, 100)); 
                        pipTarget = pipVideo; 
                    } else {
                        pipTarget = video;
                    }
                } catch (e) {
                    pipTarget = video;
                }
            }
            
            loadModel();

        } catch (err) {
            alert("System Error: " + err.message);
            startScreen.style.display = 'flex'; 
        }
    }

    function startSilentHeartbeat() {
        if (!audioCtx) return;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.connect(g); g.connect(audioCtx.destination);
        o.start(); g.gain.value = 0.0001;
    }

    // --- è­¦æŠ¥åŠŸèƒ½å‡½æ•° (Sound) ---
    function tryPlayBeep() {
        if (!audioCtx) return;
        const now = Date.now();
        if (now - lastBeepTime < BEEP_INTERVAL) return;
        lastBeepTime = now;
        if (audioCtx.state === 'suspended') audioCtx.resume();

        try {
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = 'square'; 
            o.frequency.setValueAtTime(800, audioCtx.currentTime);
            o.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.15);
            g.gain.setValueAtTime(0.5, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
            o.connect(g); g.connect(audioCtx.destination);
            o.start(); o.stop(audioCtx.currentTime + 0.15);
        } catch(e) {}
    }

    // --- è­¦æŠ¥åŠŸèƒ½å‡½æ•° (Vibration) ---
    function tryVibrate() {
        // iOS Safari ä¸æ”¯æŒ navigator.vibrateï¼Œè¿™é‡Œä¼šé™é»˜å¤±è´¥
        if (navigator.vibrate) {
            // éœ‡åŠ¨ 200ms
            navigator.vibrate([200]);
        }
    }

    function sendNotification() {
        try {
            if (window.Notification && Notification.permission === "granted") {
                const now = Date.now();
                if (window.lastNotif && now - window.lastNotif < 3000) return; 
                window.lastNotif = now;
                new Notification("âš ï¸ è¡çªè­¦å‘Šï¼", { body: "LOOK OUT!" });
            }
        } catch(e) {}
    }

    async function setupCamera() {
        const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: 'environment' }, audio: false
        });
        video.srcObject = stream;
        video.setAttribute('playsinline', ''); 
        video.setAttribute('autoplay', '');    
        video.setAttribute('muted', '');       
        return new Promise((resolve) => {
            video.onloadedmetadata = () => {
                video.play();
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                resolve(video);
            };
        });
    }

    async function loadModel() {
        fpsBadge.innerText = "LOADING AI...";
        try {
            model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
            fpsBadge.innerText = "SYSTEM ACTIVE";
            fpsBadge.style.color = "#00f3ff";
            detectFrame();
        } catch(e) {
            fpsBadge.innerText = "AI ERROR";
            fpsBadge.style.color = "red";
        }
    }

    function detectFrame() {
        const now = performance.now();
        frameCount++;
        if (video.paused) video.play().catch(()=>{});
        
        if (isEcoMode) {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const angle = (frameCount * 0.05) % (Math.PI * 2);
            ctx.strokeStyle = 'rgba(0, 243, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(angle) * 100, centerY + Math.sin(angle) * 100);
            ctx.stroke();
            const alpha = 0.5 + Math.sin(frameCount * 0.1) * 0.4;
            ctx.fillStyle = `rgba(0, 243, 255, ${alpha})`;
            ctx.font = '20px "Rajdhani"';
            ctx.textAlign = 'center';
            ctx.fillText("ECO SURVEILLANCE ACTIVE", centerX, centerY + 140);
        } else {
            if (canvas.width > 0) ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        }

        if (!isDetecting && (now - lastPredictionTime > PREDICTION_INTERVAL) && model) {
            isDetecting = true;
            model.detect(video, 20, CONFIDENCE_THRESHOLD).then(predictions => {
                processPredictions(predictions);
                lastPredictionTime = performance.now();
                isDetecting = false;
                scheduleNextFrame(); 
            }).catch(() => {
                isDetecting = false;
                scheduleNextFrame();
            });
        } else {
            renderStatus(); 
            scheduleNextFrame();
        }
    }

    function processPredictions(predictions) {
        let currentFrameDangerous = false;
        
        predictions.forEach(prediction => {
            if (['person', 'car', 'truck', 'bus'].includes(prediction.class)) {
                const [x, y, width, height] = prediction.bbox;
                const ratio = height / video.videoHeight;
                const isDanger = ratio > 0.45;

                if (!isEcoMode) {
                    const color = isDanger ? '#ff2a2a' : '#00f3ff';
                    const lineLen = width * 0.2;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(x, y + lineLen); ctx.lineTo(x, y); ctx.lineTo(x + lineLen, y);
                    ctx.moveTo(x + width - lineLen, y); ctx.lineTo(x + width, y); ctx.lineTo(x + width, y + lineLen);
                    ctx.moveTo(x + width, y + height - lineLen); ctx.lineTo(x + width, y + height); ctx.lineTo(x + width - lineLen, y + height);
                    ctx.moveTo(x + lineLen, y + height); ctx.lineTo(x, y + height); ctx.lineTo(x, y + height - lineLen);
                    ctx.stroke();

                    ctx.fillStyle = color;
                    ctx.fillRect(x, y - 25, width, 25);
                    ctx.fillStyle = 'black';
                    ctx.font = 'bold 16px "Rajdhani"';
                    ctx.textAlign = 'left';
                    ctx.fillText(prediction.class.toUpperCase() + " " + Math.round(prediction.score*100) + "%", x + 5, y - 7);
                }

                if (isDanger) currentFrameDangerous = true;
            }
        });

        if (currentFrameDangerous) lastDangerTime = Date.now();
    }

    function renderStatus() {
        const now = Date.now();
        const isEffectivelyDangerous = (now - lastDangerTime < DANGER_HOLD_TIME);

        if (isEffectivelyDangerous) {
            // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ ¹æ®è­¦æŠ¥æ¨¡å¼è§¦å‘ ---
            const shouldBeep = (alertMode === 0 || alertMode === 2);
            const shouldVibrate = (alertMode === 1 || alertMode === 2);

            if (shouldBeep) tryPlayBeep();
            
            // éœ‡åŠ¨æœ‰è‡ªå·±çš„é¢‘ç‡æ§åˆ¶ï¼Œè¿™é‡Œé€šè¿‡æ—¶é—´å·®ç®€å•æ§åˆ¶
            if (shouldVibrate) {
                // ç¡®ä¿éœ‡åŠ¨ä¸è·Ÿå£°éŸ³å†²çªï¼Œç®€å•çš„é—´éš”æ§åˆ¶
                if (now - lastBeepTime < 50) tryVibrate(); 
            }
            
            sendNotification();
            
            dangerOverlay.style.display = 'block';

            ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.moveTo(canvas.width/2, canvas.height/2 - 50);
            ctx.lineTo(canvas.width/2 - 50, canvas.height/2 + 50);
            ctx.lineTo(canvas.width/2 + 50, canvas.height/2 + 50);
            ctx.closePath();
            ctx.stroke();
            
            ctx.font = 'bold 60px "Rajdhani"';
            ctx.textAlign = 'center';
            ctx.fillText("!", canvas.width/2, canvas.height/2 + 35);
            
            // æ˜¾ç¤ºå…·ä½“çš„è­¦å‘Šæ¨¡å¼æ–‡å­—
            let warningText = "WARNING";
            if (alertMode === 1) warningText = "SILENT WARN";
            
            ctx.font = 'bold 40px "Rajdhani"';
            ctx.fillText(warningText, canvas.width/2, canvas.height/2 + 100);
        } else {
            dangerOverlay.style.display = 'none';
        }
    }

    function scheduleNextFrame() {
        if (document.hidden || document.pictureInPictureElement) {
            setTimeout(detectFrame, 50); 
        } else {
            requestAnimationFrame(detectFrame);
        }
    }

    function toggleEcoMode() {
        if (isIOS) alert("Note: iOS screen dimming manual required.");
        isEcoMode = !isEcoMode;
        if (isEcoMode) {
            ecoBtn.classList.add('active');
            ecoBtn.querySelector('span:last-child').innerText = "ON";
        } else {
            ecoBtn.classList.remove('active');
            ecoBtn.querySelector('span:last-child').innerText = "OFF";
        }
    }
    
    // --- æ–°å¢ï¼šåˆ‡æ¢è­¦æŠ¥æ¨¡å¼å‡½æ•° ---
    function toggleAlertMode() {
        alertMode = (alertMode + 1) % 3; // 0 -> 1 -> 2 -> 0 å¾ªç¯
        
        let label = "";
        let icon = "";
        
        switch(alertMode) {
            case 0: // Sound Only
                label = "SOUND ONLY";
                icon = "ğŸ”Š SOUND";
                modeBtn.classList.remove('active'); // ç™½è‰²
                break;
            case 1: // Vibrate Only
                label = "VIB ONLY";
                icon = "ğŸ“³ VIBRATE";
                modeBtn.classList.add('active'); // äº®è‰²ï¼Œæç¤ºé™éŸ³æ¨¡å¼ä¹Ÿæ˜¯æ¿€æ´»çŠ¶æ€
                if (isIOS) alert("iPhoneæ³¨æ„ï¼š\nWebã‚µã‚¤ãƒˆã‹ã‚‰ã®æŒ¯å‹•ã¯iOSã§ãƒ–ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ã¾ã™ã€‚\n(ç”»é¢ã®ç‚¹æ»…ã®ã¿æ©Ÿèƒ½ã—ã¾ã™)");
                break;
            case 2: // Both
                label = "SOUND+VIB";
                icon = "ğŸš¨ BOTH";
                modeBtn.classList.add('active'); // äº®è‰²
                break;
        }
        
        modeBtn.querySelector('span:first-child').innerText = icon;
        modeText.innerText = label;
    }

    async function togglePiP() {
        try {
            if (document.pictureInPictureElement) {
                await document.exitPictureInPicture();
            } else {
                if (pipTarget.readyState === 0) { alert("Buffering..."); return; }
                await pipTarget.requestPictureInPicture();
            }
        } catch (error) {
            if (video.webkitSetPresentationMode) {
                video.webkitSetPresentationMode(video.webkitPresentationMode === "inline" ? "picture-in-picture" : "inline");
            }
        }
    }
</script>
</body>
</html>
